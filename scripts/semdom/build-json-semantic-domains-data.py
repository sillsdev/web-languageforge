#!/usr/bin/env python

"""Parses semantic domain data from Ddp4.xml file (and related Ddp4Questions-*.xml files),
and outputs JSON data in the following format:

var semanticDomains_en = {
    '1.1': {
        'key': '1.1',  # Will be consistent across languages
        'guid': '999581c4-1611-4acb-ae1b-5e6c1dfe6f0c',
        'name': 'Sky',
        'value': '1.1 Sky',  # This may vary across languages
        'abbreviation': '1.1',
        'description': 'Use this domain for words related to the sky.',
        'searchKeys': 'sky, firmament, canopy, vault',
    },
    # ...
};

var semanticDomainQuestions_en = {
    '1.1': [
        { 'question': 'What words refer to the air around the earth? (air, atmosphere, airspace, stratosphere, ozone layer)',
          'exampleWords': 'air, atmosphere, airspace, stratosphere, ozone layer' },
          # Note: No 'exampleSentences' key for this entry in English. Some languages will have LOTS of missing keys.
        # ...
    ],
    # ...
    '3.3.4.1': [
        { 'question': '(1) What words refer to giving someone permission to do something?',
          'exampleWords': 'give permission, agree to, allow, authorize, consent to, give your consent, grant permission, let, permit, say someone can do something, not stand in someone's way, sanction, suffer, give someone the go-ahead, okay something, give someone the green light, give leave, ',
          'exampleSentences': 'John <allowed> us to use his shovel.'  # Note: Make sure this isn't coming out as &lt; and &gt;
        }
    ],
    # ...
}

Note that this format for the questions file is a **breaking change** from the
format output by the previous version of this script, which was just a list of
strings (only questions, no exampleWords or exampleSentences).

The GUIDs found in the output data will be the GUIDs that FieldWorks uses for its semantic domains, as found in
src/resources/languageforge/semdomtrans/SemDom_en.xml
"""

import os, sys
import re
from pprint import pprint, pformat
import codecs
import collections
import json
import lxml
from lxml import etree
import glob

# Constants - mostly hardcoded filenames
SEMDOM_EN_FNAME = "SemDom_en.xml"
SEMDOM_EN_DIR = "src/resources/languageforge/semdomtrans"
SEMDOM_EN_PATH = os.path.join(SEMDOM_EN_DIR, SEMDOM_EN_FNAME)
QUESTIONS_FNAME_BASE = "LocalizedLists-{}.xml"
QUESTIONS_FNAME_DIR = SEMDOM_EN_DIR
QUESTIONS_FNAME_PATH = os.path.join(QUESTIONS_FNAME_DIR, QUESTIONS_FNAME_BASE)
DEFAULT_LANG = 'en' # If any language is lacking certain domains, substitute English for missing domains
# TODO: We could build this list programmatically by globbing LocalizedLists-*.xml
ALL_LANGUAGES = ['bn', 'en', 'es', 'fa', 'fr', 'hi', 'id', 'km', 'ko', 'ms', 'my', 'ne', 'pt', 'ru', 'swh', 'te', 'th', 'ur', 'zh-CN']

OUTPUT_DIR = "src/angular-app/languageforge/js/assets"
OUTPUT_DDP_FNAME_BASE = "semanticDomains_{}.js"
OUTPUT_QUESTIONS_FNAME_BASE = "semanticDomainQuestions_{}.js"

# OUTPUT_PREFIX is the text to write *before* the JSON output
OUTPUT_PREFIX_DOMAINS = """\
'use strict';

// THIS FILE IS AUTOMATICALLY GENERATED.
// Generated by {}
// Do not make changes to this file; they will be overwritten.

// input systems languages data
var semanticDomains_{} = """

OUTPUT_PREFIX_QUESTIONS = OUTPUT_PREFIX_DOMAINS.replace('Domains_', 'DomainQuestions_')

# OUTPUT_SUFFIX is the text to write *after* the JSON output
OUTPUT_SUFFIX = ";\n"

def find_gitroot(startpath=None):
    if startpath is None:
        startpath = os.getcwd()
    curpath = os.path.abspath(startpath)
    while not os.path.exists(os.path.join(curpath, ".git")):
        parent = os.path.abspath(os.path.join(curpath, ".."))
        if parent == curpath:
            # Hit filesystem root without finding a Git repo
            return None
        curpath = parent
    return curpath

def gitrooted_filename(fname, startpath=None):
    return os.path.join(find_gitroot(startpath), fname)

def parse_file(fname):
    with codecs.open(fname, 'rU', 'utf-8-sig') as f:
        return etree.parse(f)

def get_text(elem, lang="en"):
    # Get text from either an AUni or an AStr element.
    # The "elem" param should be the "parent" element (e.g., Abbreviation) that contains either AUni or AStr
    if elem is None:
        return None
    content = elem.find(u"./AUni[@ws='{}']".format(lang))
    if content is None:
        content = elem.find(u"./AStr[@ws='{}']/Run[@ws='{}']".format(lang,lang))
    if content is None:
        return None
    return content.text

def get_questions(semdom, lang):
    # Each question will be in a dict with possible keys "question", "exampleWords", "exampleSentences"
    result = []
    for q in semdom.findall(u"./Questions/CmDomainQ"):
        record = collections.OrderedDict()
        for key, searchpath in [("question", u"./Question"), ("exampleWords", u"./ExampleWords"), ("exampleSentences", u"./ExampleSentences")]:
            text = get_text(q.find(searchpath), lang)
            if text is None:  # If this language doesn't have a translation, substitute English
                text = get_text(q.find(searchpath), DEFAULT_LANG)
            if text is None:  # Still not found? Skip entirely.
                continue
            record[key] = text
        result.append(record)
    return result

def build_semdom_data(tree, lang):
    result = collections.OrderedDict()
    for elem in tree.iter('CmSemanticDomain'):
        if not elem.attrib.has_key("guid"):
            continue
        record = collections.OrderedDict()
        record['guid'] = elem.attrib["guid"].strip().lower()  # RFC 4122 section 3 says output GUIDs should be LOWERCASE
        record['key'] = get_text(elem.find("./Abbreviation"), "en")
        if record['key'] is None:
            continue
        for key, searchpath in [("abbr", "./Abbreviation"), ("name", "./Name"), ("description", "./Description")]:
            text = get_text(elem.find(searchpath), lang)
            if text is None:  # If this language doesn't have a translation, substitute English
                text = get_text(elem.find(searchpath), DEFAULT_LANG)
            if text is None:  # Still not found? Skip entirely.
                continue
            record[key] = text
        if record.get('abbr', None) is None or record.get('name', None) is None:
            continue  # We MUST have at least an abbreviation and a name, or else we'll skip this entire record
        record['value'] = u"{} {}".format(record['abbr'], record['name'])
        questions = get_questions(elem, lang)
        if questions:
            record['questions'] = questions
        result[record['key']] = record
    return result

def extract_question_data(semdom_data, lang):
    result = collections.OrderedDict()
    for key, record in semdom_data.iteritems():
        if not record.has_key('questions'):
            continue
        qs = record['questions']
        del record['questions']  # Mutate the passed-in dictionary
        import pprint
        result[record['key']] = qs
    return result

def write_json(data, lang, out_fname, prefix, suffix):
    with codecs.open(out_fname, 'wU', 'utf-8') as f:
        f.write(prefix)
        json.dump(data, f, ensure_ascii=False, indent=2, separators=(',', ' : '))
        f.write(suffix)

def main():
    sys.stderr.write("Processing languages {}...\n".format(repr(ALL_LANGUAGES)))
    for lang in ALL_LANGUAGES:
        if lang == DEFAULT_LANG:
            translation_path = gitrooted_filename(SEMDOM_EN_PATH)
        else:
            translation_path = gitrooted_filename(QUESTIONS_FNAME_PATH.format(lang))
        if not os.path.exists(translation_path):
            sys.stderr.write("No localization file found for language tag \"{}\"; skipping this language.\n".format(lang))
            continue
        sys.stderr.write("Now processing {}\n".format(lang))
        underscore_lang = lang.replace('-', '_')  # So zh-CN doesn't produce invalid Javascript

        semdom_tree = parse_file(translation_path)
        semdom_data = build_semdom_data(semdom_tree, lang)
        questions = extract_question_data(semdom_data, lang)
        output_dir = gitrooted_filename(OUTPUT_DIR)
        fname = os.path.join(output_dir, OUTPUT_DDP_FNAME_BASE.format(lang))
        write_json(semdom_data, lang, fname, OUTPUT_PREFIX_DOMAINS.format(__file__, underscore_lang), OUTPUT_SUFFIX)
        fname = os.path.join(output_dir, OUTPUT_QUESTIONS_FNAME_BASE.format(lang))
        write_json(questions, lang, fname, OUTPUT_PREFIX_QUESTIONS.format(__file__, underscore_lang), OUTPUT_SUFFIX)

if __name__ == '__main__':
    main()
